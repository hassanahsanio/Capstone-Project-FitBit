# -*- coding: utf-8 -*-
"""Week8(Hassan_Ahsan)Capstone Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kDZUfEiEoqhF7FjS82shK1CajjdozWa6

# WEEK 8 Capstone Project
# **FITBIT CONSUMER BEHAVIOUR ANALYSIS**

![img](https://130e178e8f8ba617604b-8aedd782b7d22cfe0d1146da69a52436.ssl.cf1.rackcdn.com/fitbit-hack-what-are-lessons-showcase_image-6-a-8793.jpg)

## INTRODUCTION
Fitbit Inc. is an American consumer electronics and fitness company. It produces wireless-enabled wearable technology, physical fitness monitors and activity trackers such as smartwatches, pedometers and monitors for heart rate, quality of sleep and stairs climbed as well as related software. The company was acquired by Google in January 2021.
The company was founded as Healthy Metrics Research, Inc. in San Francisco, California, on March 26, 2007, by *James Park* (CEO) and *Eric Friedman* (CTO).

# OBJECTIVE
Imagine you are a data analyst at **“HealthTrackers Inc.**,” a fictional company operating in the Fitbit industry. Your company is dedicated to understanding consumer behavior to enhance product offerings and optimize marketing strategies. You have been tasked with analyzing a comprehensive dataset obtained from Fitbit users to uncover trends and insights. The business objective is to identify key trends, understand their implications for customers, and leverage these insights to shape an effective marketing strategy.

# BUSINESS TASK
Analyze FitBit Fitness Tracker App data to gain insights into how consumers are using the FitBit app and discover trends and insights for the marketing team.

# BUSINESS OBJECTIVE
- What are the trends identified?
- How could these trends apply to customers?
- How could these trends help influence marketing strategy?

## 1. Data Source:
1. The data is given to us by our mentor available through Google Drive. It contains personal fitness tracker data from over 30 FitBit users who have given consent to use their data.
2. There are 18 csv files total, but the datasets used according to the product analysis are `daily activity`, `hourly calories`, `hourly steps`, `sleep day`, `daily_calories`, `daily_intensity`, `weight_log` and `daily_steps`dataset.

## 2. Sorting the data
1. To have a quick overview of the chosen data, I opened each of them in MS Excel. The first thing I noticed was that the data was organized in a long format. I also noticed that the `dailyActivity_merged` data contains some metrics that can give us some insights like the total steps taken by the Fitbit users, the active minutes spent, and the calories burned. With that we can establish some correlation between calories burned and the steps taken. The hourly calories and the hourly steps contain info about the activity hour that will help give some insight about calories and the time of the day.

2. Then I created a separate folder on my desktop to store the files, since I was going to use Jupyter Notebook to process the data.

## 3. Loading Libraries
Let's start by loading libraries for data processing and visualization.
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import pandas as pd
import numpy as np
import datetime as dt
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings(action='ignore', category=FutureWarning)
warnings.filterwarnings(action='ignore', category=UserWarning)

"""## 4. Loading datasets
We will be loading the relevant datasets necessary for the analysis.

Mounting Data
"""

from google.colab import drive
drive.mount('/content/drive')

daily_activity = pd.read_csv('/content/drive/MyDrive/PrepInsta_Wokerd/week 8/dailyActivity_merged.csv')
hourly_steps = pd.read_csv('/content/drive/MyDrive/PrepInsta_Wokerd/week 8/hourlySteps_merged.csv')
hourly_calories = pd.read_csv('/content/drive/MyDrive/PrepInsta_Wokerd/week 8/hourlyCalories_merged.csv')
sleepday = pd.read_csv('/content/drive/MyDrive/PrepInsta_Wokerd/week 8/sleepDay_merged.csv')
daily_calories = pd.read_csv('/content/drive/MyDrive/PrepInsta_Wokerd/week 8/dailyCalories_merged.csv')
daily_intensity = pd.read_csv('/content/drive/MyDrive/PrepInsta_Wokerd/week 8/dailyIntensities_merged.csv')
weight_log = pd.read_csv('/content/drive/MyDrive/PrepInsta_Wokerd/week 8/weightLogInfo_merged.csv')
daily_steps = pd.read_csv('/content/drive/MyDrive/PrepInsta_Wokerd/week 8/dailySteps_merged.csv')
heartrate_secs = pd.read_csv('/content/drive/MyDrive/PrepInsta_Wokerd/week 8/heartrate_seconds_merged.csv')

"""## 5. Data Exploration
Let's explore our data by viewing some information about them.

### Showing the first 5 rows of each dataset.
"""

daily_activity.head()

hourly_steps.head()

hourly_calories.head()

sleepday.head()

daily_calories.head()

daily_intensity.head()

weight_log.head()

daily_steps.head()

heartrate_secs.head()

"""### Let's see how many unique users are present in each dataset."""

print("Daily Activity Dataset:",daily_activity.Id.nunique(), "unique users")
print("Hourly Steps Dataset:",hourly_steps.Id.nunique(), "unique users")
print("Hourly Calories Dataset:",hourly_calories.Id.nunique(), "unique users")
print("SleepDay Dataset:",sleepday.Id.nunique(), "unique users")
print("Daily Calories Dataset:",daily_calories.Id.nunique(), "unique users")
print("Daily Intensity Dataset:",daily_intensity.Id.nunique(), "unique users")
print("Weight Logged Dataset:",weight_log.Id.nunique(), "unique users")
print("Daily Steps Dataset:",daily_steps.Id.nunique(), "unique users")
print("Heart Rate Dataset:",heartrate_secs.Id.nunique(), "unique users")

"""### Let's view the data types in each dataset."""

daily_activity.dtypes

hourly_steps.dtypes

hourly_calories.dtypes

sleepday.dtypes

daily_calories.dtypes

daily_intensity.dtypes

weight_log.dtypes

daily_steps.dtypes

heartrate_secs.dtypes

"""### Let's view their shape."""

print("Shape of Daily Activity:",daily_activity.shape)
print("Shape of Hourly Steps:",hourly_steps.shape)
print("Shape of Hourly Calories:",hourly_calories.shape)
print("Shape of SleepDay:",sleepday.shape)
print("Shape of Daily Calories:",daily_calories.shape)
print("Shape of Daily Intensity:",daily_intensity.shape)
print("Shape of Weight Logged:",weight_log.shape)
print("Shape of Daily Steps:",daily_steps.shape)
print("Shape of Heart Rate:",heartrate_secs.shape)

"""### Checking if the datasets have missing values."""

print("Daily Activity Dataset has",daily_activity.isnull().values.sum(), "missing values")
print("Hourly Steps Dataset has",hourly_steps.isnull().values.sum(), "missing values")
print("Hourly Calories Dataset has",hourly_calories.isnull().values.sum(), "missing values")
print("SleepDay Dataset has",sleepday.isnull().values.sum(), "missing values")
print("Daily Calories Dataset has",daily_calories.isnull().values.sum(), "missing values")
print("Daily Intensity Dataset has",daily_intensity.isnull().values.sum(), "missing values")
print("Daily Steps Dataset has",daily_steps.isnull().values.sum(), "missing values")
print("Heart Rate Dataset has",heartrate_secs.isnull().values.sum(), "missing values")

"""**As we can see that all the dataset has 0 missing/null values. The data preprocessing will be easier in this case.**

### Checking the dataset for duplicates.
"""

print("Duplicates in Daily Acitivity: ", daily_activity.duplicated().head(3))
print("Duplicates in Hourly Steps: ", hourly_steps.duplicated().head(3))
print("Duplicates in Hourly Calories: ", hourly_calories.duplicated().head(3))
print("Duplicates in Sleepday: ", sleepday.duplicated().head(3))
print("Duplicates in Daily Calories: ", daily_calories.duplicated().head(3))
print("Duplicates in Daily Intensity: ", daily_intensity.duplicated().head(3))
print("Duplicates in Daily Steps: ", daily_steps.duplicated().head(3))
print("Duplicates in Heart Rate: ", heartrate_secs.duplicated().head(3))

"""We can see that there are no duplicate values present in the datsets.

#### Summary of Initial Findings

- Of all the datasets we inspected, `heartrate_secs`, `weight_logged` and `sleepday` fell short of our **n>=30** rule (NOTE: here n refers to sample size). `heartrate_secs` has **n=14**, and `weight_logged` only has **n=8**, hence we’re going to drop both of them. `sleepday` has **n=24**, which is also quite small. However, we are going to keep it, since we might gain some relevant insights from it.
- `daily_calories`, `daily_intensity`, and `daily_steps` all have exactly the same data that is found in the `daily_activity` dataset. **StepTotal** in `daily_intensity` was only changed to **TotalSteps** in `daily_activity` datasets. Other than that, they are the same data. Hence, we’ll discard them. Leaving us with `daily_activity`, `hourly_steps`, `hourly_calories`, and `sleepday` datasets.
- From the shape, I observed that `hourly_steps` and `hourly_calories` have similar structures: (22099, 3). Hence, we can decide to merge them for further analysis.
- As for the data types, **ActivityDate** in `daily_activity`, **ActivityHour** in `hourly_steps`, **ActivityHour** in `hourly_calories`, and **SleepDay** in `sleepday` are *objects* instead of *datetime* data type. We’ll have to convert them to *datetime* data type for easy processing.
- There are **NO** missing values and duplicates in all datasets.

## 6. DATA TRANSFORMATION
Let's start by converting the **ActivityDate** in `daily_activity`, **ActivityHour** in `hourly_steps`, **ActivityHour** in `hourly_calories`, and **SleepDay** in `sleepday` to *datetime* data type.
"""

daily_activity["ActivityDate"] = pd.to_datetime(daily_activity["ActivityDate"])
hourly_steps["ActivityHour"] = pd.to_datetime(hourly_calories["ActivityHour"])
hourly_calories["ActivityHour"] = pd.to_datetime(hourly_calories["ActivityHour"])
sleepday["SleepDay"] = pd.to_datetime(sleepday["SleepDay"])

"""### Checking for Changes."""

print("Daily Activity data type is", daily_activity["ActivityDate"].dtypes, "data type")
print("Hourly Steps data type is", hourly_steps["ActivityHour"].dtypes, "data type")
print("Hourly Calories data type is", hourly_calories["ActivityHour"].dtypes, "data type")
print("Sleepday data type is", sleepday["SleepDay"].dtypes, "data type")

"""### Merging `hourly_steps` with `hourly_calories` dataset below."""

for col in hourly_steps.columns, hourly_calories.columns:
    print (col)

"""**We can see above that they both share `Id` and `ActivityHour` in common. Hence, we'll merge them on `Id` and `ActivityHour` below.**"""

merge_df = pd.merge(hourly_steps, hourly_calories,
                    on=['Id', 'ActivityHour'], how='inner')

merge_df.head()

"""### Creating new columns.

Let's create a new column (WeekDay) from the `ActivityHour` in our new dataset `merged_df`, and `ActivityDate` in `daily_activity`. This will help us see if the days of the week has any bearing on our analysis.
"""

daily_activity["WeekDay"] = daily_activity["ActivityDate"].dt.day_name()
merge_df["WeekDay"] = merge_df["ActivityHour"].dt.day_name()
sleepday["WeekDay"] = sleepday["SleepDay"].dt.day_name()

# viewing changes
merge_df.head()

"""**We still need to make some changes to the `merge_df` dataframe. We need to extract the `ActivityHour` column by creating a separate column.**"""

merge_df["DateHour"] = merge_df["ActivityHour"].dt.hour

merge_df.head()

"""**We have created a separate column `DateHour`, let's remove the Hour, min, and sec.**"""

merge_df["ActivityDay"] = merge_df["ActivityHour"].dt.date

"""### Drop ActivityHour column"""

merge_df = merge_df.drop("ActivityHour", axis = 1)
merge_df.head()

"""### Changing ActivityDay column to DateTime data type."""

merge_df["ActivityDay"] = pd.to_datetime(merge_df["ActivityDay"])

"""**We're going to merge `sleepday` with `merge_df` to create a new dataframe that contains sleepday record with calories for some analysis. Hence, before we do, let's change the column name `SleepDay` in sleepday df, so it matches `ActivityDay` in merge_df.**"""

sleepday = sleepday.rename(columns={'SleepDay': 'ActivityDay'})
sleepday.head()

"""**Merging `sleepday` with `merge_df`. But first, let's see what the columns they share in common.**"""

for col in merge_df.columns, sleepday.columns:
    print (col)

"""**Since they have `Id`, `ActivityDay` and `WeekDay` in common, we'll merge both dataframes on `Id`, `ActivityDay` and `WeekDay`.**"""

merge_df2 = pd.merge(merge_df, sleepday,
                    on=['Id', 'ActivityDay', 'WeekDay'], how='inner')

merge_df2.head(5)

# Let's see how many unique users and missing values we have in our new dataframe
print("Merge_df2 Dataframe has",merge_df2.Id.nunique(), "unique users")
print("Merge_df2 DataFrame has",merge_df2.isnull().values.sum(), "missing values")

"""**Making some changes to the `daily_activity` dataframe. We'll start by creating 2 additional columns (`TotalActiveMinutes`, `TotalMinutes`, and `TotalActiveHours`). Then we'll remove some columns we won't need.**"""

new_cols = ["Id", "ActivityDate",
            "WeekDay", "TotalSteps",
            "TotalDistance", "VeryActiveDistance",
            "ModeratelyActiveDistance", "LightActiveDistance",
            "SedentaryActiveDistance", "VeryActiveMinutes",
            "FairlyActiveMinutes", "LightlyActiveMinutes",
            "SedentaryMinutes", "TotalActiveMinutes",
            "TotalMinutes", "TotalActiveHours", "Calories"]

daily_activity = daily_activity.reindex(columns=new_cols)

daily_activity[["TotalActiveMinutes",
                "TotalMinutes", "TotalActiveHours"]].head()

"""**The `TotalActiveMinutes` and `TotalMinutes` columns have been created, but they currently don't have any values since they have not been created.**

**For the **`TotalActiveMinutes`**, I will create the values by summing up all the active minutes i.e `VeryActiveMinutes`, `FairlyActiveMinutes`, and `LightActiveMinutes` and for the **`TotalMinutes`**, I will sum up the `TotalActiveMinutes` and the `SedentaryMinutes`.**
"""

daily_activity["TotalActiveMinutes"] = daily_activity["VeryActiveMinutes"] + daily_activity["FairlyActiveMinutes"] + daily_activity["LightlyActiveMinutes"]
daily_activity["TotalMinutes"] = daily_activity["TotalActiveMinutes"] + daily_activity["SedentaryMinutes"]
daily_activity["TotalActiveHours"] = round(daily_activity["TotalActiveMinutes"] / 60)

daily_activity[["TotalActiveMinutes", "TotalMinutes", "TotalActiveHours"]].head()

"""## 7. Analyzing the data
**Our data is processing is complete, and now it's time to analyze it for insights. We have narrowed down our datasets to 3 dataframes**:
- `daily_activity`
- `merge_df`
- `merge_df2`

**We're going to draw the insights from these dataframes.
Let's get statistical info from them.**
"""

daily_activity.describe()

merge_df.describe()

merge_df2.describe()

"""### Key  findings:
- Out of 1218 Total minutes, 991 minutes were spent inactive (Sedentary). Approximately 228 active minutes were spent.
- An average of 7638 total steps were taken by the users daily.
- There is also an average of 2304 calories burnt daily.
- Also, there is a positive correlation between steps taken and calories burnt.

## 8. Visualizing the data

#### Creating a Correlation heatmap to show the positive and negative correlation among the columns.
"""

Corr1 = ["TotalDistance", "TotalSteps",
         "SedentaryMinutes", "TotalActiveMinutes", "Calories"]

fig, ax = plt.subplots(figsize=(15, 8))
ax = sns.heatmap(daily_activity[Corr1].corr(),
            annot = True,
            fmt = ".2f",
            linewidths=0.5,
           cmap="icefire")

ax.set_title('Correlation Matrix');

"""### KEY FINDINGS:
- There is a positive correlation between `Calories` and `TotalActiveMinutes`, `TotalSteps`, and `TotalDistance`.
- There is a negative correlation between `Calories` and `SedentaryMinutes`.

### Comparing Total Steps and Sedantary Minutes to Calories.
"""

fig, (ax0, ax1) = plt.subplots(nrows=2,
                             ncols=1,
                             figsize=(10, 10),
                               sharex=True)

scatter = ax0.scatter(x=daily_activity["Calories"],
                     y=daily_activity["TotalSteps"],
                     color="lightgreen")
ax0.set(title="Calories Burnt By Total Steps",
       ylabel="Total Steps")

ax0.legend(*scatter.legend_elements(), title=None)

scatter = ax1.scatter(x=daily_activity["Calories"],
                     y=daily_activity["SedentaryMinutes"],
                     color="skyblue")
ax1.set(title="Sedentary Minutes and Calories",
       ylabel="Sedentary Minutes")

ax1.legend(*scatter.legend_elements(), title=None);

"""### KEY FINDINGS:
- This scatterplot gives us a clearer view of the correlation between `TotalSteps` and `SedentaryMinutes` to `Calories`.
- The more the steps taken, the more the calories burnt.
- On the other hand, the more the Sedentary minutes, the less the calories burnt.

### Showing amount of calories burnt for every steps taken in a scatter plot shown below.
"""

plt.style.use("default")
plt.figure(figsize=(8,6)) # specify size of the chart
plt.scatter(daily_activity["TotalSteps"],daily_activity["Calories"],
            alpha = 0.8, c = daily_activity["Calories"],
            cmap = "Spectral")

# add annotations and visuals
median_calories = 2134
median_steps = 7405

plt.colorbar(orientation = "vertical")
plt.axvline(median_steps, color = "Blue", label = "Median steps")
plt.axhline(median_calories, color = "Red", label = "Median calories burned")
plt.xlabel("Steps taken")
plt.ylabel("Calories burned")
plt.title("Calories burned for every step taken")
plt.grid(True)
plt.legend()
plt.show()

"""### KEY FINDINGS:
From the scatter plot, we infer that:
1. It is a positive correlation.
2. Observed that intensity of calories burned increase when users are at the range of >0 to 15,000 steps with calories burn rate cooling down from 15,000 steps onwards.
3. Noted a few outliers:
- 0 steps with 0 to minimal calories burned.
- 1 observation of >35,000 steps with <3,000 calories burned.
- Deduced that outliers could be due to natural variation of data, change in user's usage or errors in data collection (ie. miscalculations or human error).

### Relation between Sedantary Minutes VS Total Active Minutes shown below.
"""

fig, ax = plt.subplots(figsize=(8, 5))

x = np.array(["Sedentary Minutes", "Total Active Minutes"])
y = np.array([daily_activity["SedentaryMinutes"].mean(),
              daily_activity["TotalActiveMinutes"].mean()])

# Bar plot
bars = ax.bar(x, y, width=0.8, color="cyan")

# Adding annotations
for bar in bars:
    yval = bar.get_height()
    ax.text(bar.get_x() + bar.get_width()/2, yval + 0.1, round(yval, 2), ha='center', va='bottom')

plt.title("Sedentary Minutes Vs Total Active Minutes")
plt.show()

"""### KEY FINDINGS:
- There is a huge gap between SedentaryMinutes and TotalActiveMinutes.
- It's obvious that the users spend more time sitting or lying down, than they do being active. This data can also show us something about their lifestyle or occupation. We can assume that most likely they belong to the working class that spends countless hours behind their desk.

### Showing the Total Calories burnt by each day of the week in a bar chart.
"""

fig, ax = plt.subplots(figsize=(10,5))
plt.bar(merge_df.WeekDay, merge_df.Calories, color = "seagreen")
plt.xlabel("Week Day")
plt.ylabel("Calories Burned")
plt.title("Calories Burned by Day of the Week")
plt.grid()

plt.show()

"""### KEY FINDINGS:
- This plot shows that the most calories were burnt on **Saturday** and that the least calories were burnt on **Monday**.
- **Saturday** is quite understandable being that it is a weekend and the users probably have enough time to exercise. ***Monday***, on the other hand, is quite strange, given that is seen to be one of the busiest days at work for most people.
- The first thing that came to mind is the fact that the users could probably be very busy behind their work desks that they barely have enough time to exercise or take a walk.

### Showing the Total Steps walked every day for the week in a bar chart.
"""

fig, ax = plt.subplots(figsize=(10,5))
plt.bar(daily_activity.WeekDay, daily_activity.TotalSteps,
        color = "pink")
plt.xlabel("WEEK DAY")
plt.ylabel("TOTAL STEPS TAKEN")
plt.title("TOTAL STEPS TAKEN BY THE DAY OF THE WEEK")
plt.grid()
plt.show()

"""### KEY FINDINGS:
- This gives us the true picture of why Sunday recorded the most calories burnt. Here we see that the least steps were taken by the users on Monday compared to the other days of the week. Meaning they probably spent more hours sitting behind their work desks.
- It also gives us a clue about the profile of the users in the survey. They are most likely working class individuals.
- The most steps were taken on Saturday and Sunday.

### Showing the total minutes spent asleep daily in a week.
"""

fig, ax = plt.subplots(figsize=(10,5))
x = merge_df2["WeekDay"]
y = merge_df2["TotalMinutesAsleep"]

plt.title("TOTAL TIME SLEPT BY DAY OF THE WEEK")
plt.xlabel("WEEKDAY")
plt.ylabel("TOTAL MINUTES SLEPT")
plt.bar(x, y, width = 0.8, color = "turquoise")
plt.show()

"""### KEY FINDINGS:
- The least amount of sleep was taken on **Thursday** and the most amount of sleep was taken on **Monday**. Usually people tend to sleep longer when they are more exhausted.
- However, we can also see that the users also slept longer hours on **Saturday**, **Tuesday**, and **Sunday**, which were also the days when they lost the most calories.

### Showing the percentage of activities done in minutes in a pie chart.
"""

# calculating total of individual minutes column
very_active_mins = daily_activity["VeryActiveMinutes"].sum()
fairly_active_mins = daily_activity["FairlyActiveMinutes"].sum()
lightly_active_mins = daily_activity["LightlyActiveMinutes"].sum()
sedentary_mins = daily_activity["SedentaryMinutes"].sum()

# plotting pie chart
slices = [very_active_mins, fairly_active_mins, lightly_active_mins, sedentary_mins]
labels = ["Very active minutes", "Fairly active minutes", "Lightly active minutes", "Sedentary minutes"]
colours = ["lightcoral", "yellowgreen", "lightskyblue", "darkorange"]
explode = [0, 0, 0, 0.1]
plt.style.use("default")
plt.pie(slices, labels = labels,
        colors = colours, wedgeprops = {"edgecolor": "black"},
        explode = explode, autopct = "%1.1f%%")
plt.title("Percentage of Activity in Minutes")
plt.tight_layout()
plt.show()

"""### KEY FINDINGS:
- Sedentary minutes takes the biggest slice at 81.3%.
- This indicates that users are using the FitBit app to log daily activities such as daily commute, inactive movements (moving from one spot to another) or running errands.
- App is rarely being used to track fitness (ie. running) as per the minor percentage of fairly active activity (1.1%) and very active activity (1.7%). This is highly discouraging as FitBit app was developed to encourage fitness.

### Most and Least active hours of the day shown in the bar chart.
"""

fig, axs = plt.subplots(figsize=(23, 15))

# Group by 'DateHour' and calculate the mean of 'StepTotal'
mean_steps_by_hour = merge_df.groupby('DateHour')['StepTotal'].mean()

# Create a bar plot
mean_steps_by_hour.plot(kind='bar', rot=0, ax=axs, color='lightskyblue', title='MOST AND LEAST ACTIVE HOURS OF THE DAY')

# Adding annotations above each bar
for p in axs.patches:
    height = p.get_height()
    axs.annotate(f'{height:.2f}', (p.get_x() + p.get_width() / 2., height),
                ha='center', va='bottom', xytext=(0, 10), textcoords='offset points',rotation=45)

plt.xlabel("HOUR OF THE DAY")
plt.ylabel("TOTAL STEPS TAKEN")
plt.show()

"""### FINDINGS:
Here we can see that their day starts getting really busy from 8 a.m. in the morning to all the way to 7 p.m. in the evening. The least active hours of the day are between 8 p.m and 10 p.m. These are probably the best hours to reach them with targetted ads.

## 9. Recommendations
In this final step, we will be delivering our insights and providing recommendations based on our analysis.

Here, we will revisit our business questions and share with you our business recommendations.

1. **Promotion**: The data we explored revealed that consumers are less active between 8p.m. and 10 p.m., shortly before they retire for the night. This is the ideal moment for HealthTrackers Inc. to schedule their advertising initiatives for optimal results. Google AdWords, for example, allows internet advertisers to schedule when their adverts are shown with its ad scheduling function. Such functions can allow HealthTrackers Inc. to effectively reach its consumers. Scheduling adverts will also help Bellabeat save money on advertisements.

2. **Retention**: The objective of any membership program is not limited to generating a regular stream of new members. Retention is crucial! According to an online report, eighty percent of customers quit their subscription to a member site within the first two years of joining the site. For FitBit to retain its consumers, it must focus on personalized contents that offer value. For instance, the data revealed a positive correlation between the number of steps walked and the number of calories burnt. The more steps a person takes each day, the more calories they burn.

3. The data also revealed that one of the issues people have is that they are hardly able to reach the minimum **10,000** steps per day **recommended** for healthy adults. To address this issue, HealthTrackers Inc. can provide fascinating tips to assist its consumers achieve their daily objectives. This may be published periodically on its website. Additionally, it can create engaging challenges to motivate its users to walk regularly. This will not only drive engagement, but also provide enormous value to them.

4. I also noted that people spend far more time being inactive than being active. Inactivity is related with several health problems, including obesity, heart disease, stroke, etc. HealthTrackers Inc. can create explainer videos and blogs to educate its users about the negative impacts of sedentary lifestyle and how to prevent them. This is also a fantastic opportunity for FitBit to provide users with lifestyle-related health data, which links to the FitBit app to offer users with insights on their daily wellbeing.

5. How could these trends help influence FitBit marketing strategy?

    HealthTrackers Inc. marketing team can encourage users by educating and equipping them with knowledge about fitness benefits, suggest different types of exercise (ie. simple 10 minutes exercise on weekday and a more intense exercise on weekends) and calories intake and burnt rate information on the FitBit app.

    On weekends, FitBit app can also prompt notification to encourage users to exercise.
"""